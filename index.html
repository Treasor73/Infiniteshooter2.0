<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Survival Spiel</title>
<style>
canvas {
  background: #111;
  display: block;
  margin: auto;
}
body {
  margin: 0;
  overflow: hidden;
  user-select: none;
  font-family: Arial, sans-serif;
}
/* Overlays (Start, Pause, GameOver, Shop) */
.overlay {
  position: absolute;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  background: rgba(0,0,0,0.85);
  color: white;
  text-align: center;
  padding: 20px;
}
.card {
  background: rgba(255,255,255,0.03);
  padding: 18px;
  border-radius: 12px;
  min-width: 320px;
  max-width: 720px;
  box-shadow: 0 6px 18px rgba(0,0,0,0.6);
}
button {
  margin: 8px;
  padding: 10px 18px;
  font-size: 16px;
  border: none;
  border-radius: 8px;
  cursor: pointer;
}
.shop-list { text-align:left; margin-top:12px; }
.item-row { display:flex; justify-content:space-between; align-items:center; gap:12px; padding:8px 0; }
.small { font-size:14px; color:#ddd; }
#shopContainer { max-height: 60vh; overflow:auto; width:100%; }

/* Make shop opaque and full cover, and add close X in top-left */
#shopScreen { background: rgba(0,0,0,1); } /* fully cover */
#shopScreen .card { background: #111; } /* non-transparent card */
#shopCloseX {
  position: absolute; left: 12px; top: 12px; z-index: 50;
  background: transparent; color: white; border: none; font-size: 22px; cursor: pointer;
}
.binding-input { width: 56px; text-align:center; font-weight:bold; }

/* layout for bindings inside start/pause card */
.bindings { text-align:left; margin-top:8px; }
.binding-row { display:flex; align-items:center; justify-content:space-between; gap:12px; padding:6px 0; }
</style>
</head>
<body>
<canvas id="gameCanvas" width="800" height="600"></canvas>
<!-- START SCREEN -->
<div id="startScreen" class="overlay" style="display:flex;">
  <div class="card">
    <h1>Survival — Startmenü</h1>
    <p class="small">Steuerung des Spiels:</p>
    <ul style="text-align:left;">
      <li><b>WASD</b> – Bewegen</li>
      <li><b>Linksklick / Leertaste</b> – Schießen</li>
      <li><b>Rechtsklick / Shift</b> – Wand platzieren</li>
      <li><b>ESC</b> – Pause</li>
    </ul>
    <!-- Item Key bindings (editable) -->
    <div class="bindings">
      <div class="binding-row">
        <div>Slow-Item-Key (Slow Item)</div>
        <input id="bindingSlow" class="binding-input" maxlength="1" />
      </div>
      <div class="binding-row">
        <div>Piercing-Item-Key (Piercing Item)</div>
        <input id="bindingPierce" class="binding-input" maxlength="1" />
      </div>
      <div class="binding-row">
        <div>Wave-Skip-Key (Wave Skip Item)</div>
        <input id="bindingSkip" class="binding-input" maxlength="1" />
      </div>
    </div>

    <div style="margin-top:12px;">
      <button id="openShopBtn">Shop</button>
      <button id="playBtn">Endless Mode</button>
    </div>
    <p class="small" style="margin-top:8px;">Münzen: <span id="startCoins">0</span></p>
  </div>
</div>

<!-- PAUSE MENU -->
<div id="pauseMenu" class="overlay">
  <div class="card">
    <h1>Pausiert</h1>
    <p class="small">Steuerung: WASD, Schießen: Linksklick / Leertaste, Wände: Rechtsklick / Shift</p>

    <!-- Same bindings in pause for quick change -->
    <div class="bindings">
      <div class="binding-row">
        <div>Slow-Item-Key (Slow Item)</div>
        <input id="pauseBindingSlow" class="binding-input" maxlength="1" />
      </div>
      <div class="binding-row">
        <div>Piercing-Item-Key (Piercing Item)</div>
        <input id="pauseBindingPierce" class="binding-input" maxlength="1" />
      </div>
      <div class="binding-row">
        <div>Wave-Skip-Key (Wave Skip Item)</div>
        <input id="pauseBindingSkip" class="binding-input" maxlength="1" />
      </div>
    </div>

    <button id="resumeBtn">Fortsetzen</button>
  </div>
</div>
<!-- GAME OVER -->
<div id="gameOverScreen" class="overlay">
  <div class="card">
    <h1>GAME OVER</h1>
    <p id="finalScore"></p>
    <button id="reviveBtn">Für 100 Münzen wiederbeleben</button>
    <button id="restartBtn">Neustart</button>
  </div>
</div>
<!-- SHOP -->
<div id="shopScreen" class="overlay">
  <button id="shopCloseX" title="Zurück ins Hauptmenü">✕</button>
  <div class="card">
    <h2>Shop</h2>
    <p class="small">Stock wird alle 5 Minuten global neu gesetzt.</p>
    <div id="shopContainer">
      <div class="shop-list" id="shopList">
        <!-- Items werden per JS eingefügt -->
      </div>
    </div>
    <p class="small">Münzen: <span id="shopCoins">0</span></p>
    <p class="small">Nächster Restock in: <span id="restockTimer">--:--</span></p>
    <div style="margin-top:12px;">
      <button id="closeShopBtn">Zurück</button>
    </div>
  </div>
</div>
<script>
// === Storage laden, falls vorhanden ===
const savedWave = localStorage.getItem("wave");
const savedEnemySpeed = localStorage.getItem("enemySpeed");
const savedScore = localStorage.getItem("score");
const savedCoins = localStorage.getItem("coins");
const savedHighScore = localStorage.getItem("highScore");
const savedHighWave = localStorage.getItem("highWave");
// binding keys
const savedBindSlow = localStorage.getItem("bindSlow");
const savedBindPierce = localStorage.getItem("bindPierce");
const savedBindSkip = localStorage.getItem("bindSkip");

const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const pauseMenu = document.getElementById("pauseMenu");
const gameOverScreen = document.getElementById("gameOverScreen");
const finalScore = document.getElementById("finalScore");
const reviveBtn = document.getElementById("reviveBtn");
const restartBtn = document.getElementById("restartBtn");

// Start & Shop elements
const startScreen = document.getElementById("startScreen");
const playBtn = document.getElementById("playBtn");
const openShopBtn = document.getElementById("openShopBtn");
const startCoinsEl = document.getElementById("startCoins");
const shopScreen = document.getElementById("shopScreen");
const shopCoinsEl = document.getElementById("shopCoins");
const closeShopBtn = document.getElementById("closeShopBtn");
const shopListEl = document.getElementById("shopList");
const restockTimerEl = document.getElementById("restockTimer");
const shopCloseX = document.getElementById("shopCloseX");

// binding inputs (start + pause)
const bindingSlow = document.getElementById("bindingSlow");
const bindingPierce = document.getElementById("bindingPierce");
const bindingSkip = document.getElementById("bindingSkip");
const pauseBindingSlow = document.getElementById("pauseBindingSlow");
const pauseBindingPierce = document.getElementById("pauseBindingPierce");
const pauseBindingSkip = document.getElementById("pauseBindingSkip");
const player = {
  x: 400,
  y: 300,
  size: 20,
  speed: 4.5,
  lastDir: "right",
  alive: true
};

let bullets = [];
let enemies = [];
let walls = [];
let totalWallsBuilt = 0;

let maxWalls = 10;
let wave = savedWave !== null ? parseInt(savedWave) : 1;
let enemySpeed = savedEnemySpeed !== null ? parseFloat(savedEnemySpeed) : 1.5;
let spawnCooldown = 0;
let paused = false;
let score = savedScore !== null ? parseInt(savedScore) : 0;
let coins = savedCoins !== null ? parseInt(savedCoins) : 0;
let highScore = savedHighScore !== null ? parseInt(savedHighScore) : 0;
let highWave = savedHighWave !== null ? parseInt(savedHighWave) : 0;

// inventory: counts of items the player owns (bought)
let inventory = { slow: 0, pierce: 0, skip: 0 };

// Shop + item flags
let playerPiercing = false; // used when consuming pierce item on activation
let enemySlowMultiplier = 1; // 0.5 during slow effect
let slowTimeoutId = null;

// Key bindings: default values if not saved
let bindSlow = savedBindSlow || "1";
let bindPierce = savedBindPierce || "2";
let bindSkip = savedBindSkip || "3";
// show coins and populate binding inputs
startCoinsEl.textContent = coins;
shopCoinsEl.textContent = coins;
bindingSlow.value = bindSlow.toUpperCase();
bindingPierce.value = bindPierce.toUpperCase();
bindingSkip.value = bindSkip.toUpperCase();
pauseBindingSlow.value = bindSlow.toUpperCase();
pauseBindingPierce.value = bindPierce.toUpperCase();
pauseBindingSkip.value = bindSkip.toUpperCase();
function drawPlayer() {
  ctx.fillStyle = "cyan";
  ctx.fillRect(player.x, player.y, player.size, player.size);
}

function drawBullets() {
  bullets.forEach(b => {
    ctx.fillStyle = (Math.hypot(b.dx, b.dy) > 6) ? "yellow" : "white";
    ctx.fillRect(b.x, b.y, b.size, b.size);
  });
}

function drawEnemies() {
  ctx.fillStyle = "red";
  enemies.forEach(e => ctx.fillRect(e.x, e.y, e.size, e.size));
}

function drawWalls() {
  ctx.fillStyle = "gray";
  walls.forEach(w => ctx.fillRect(w.x, w.y, w.size, w.size));
}

function drawUI() {
  ctx.fillStyle = "white";
  ctx.font = "20px Arial";
  ctx.fillText(`Welle: ${wave-1}`, 10, 25);
  ctx.fillText(`Wände: ${totalWallsBuilt}/${maxWalls}`, 10, 50);
  ctx.fillText(`Punkte: ${score}`, 10, 75);
  ctx.fillText(`Münzen: ${coins}`, 10, 100);
  ctx.fillText(`Inv S:${inventory.slow} P:${inventory.pierce} K:${inventory.skip}`, 10, 130);
  ctx.fillText(`Highscore: ${highScore}`, 10, 150);
  ctx.fillText(`Rekordwelle: ${highWave}`, 10, 175);
}

function checkWallCollision(x, y, w, h) {
  return walls.some(wall => (
    x < wall.x + wall.size &&
    x + w > wall.x &&
    y < wall.y + wall.size &&
    y + h > wall.y
  ));
}

function isColliding(a, b) {
  return (
    a.x < b.x + b.size &&
    a.x + a.size > b.x &&
    a.y < b.y + b.size &&
    a.y + a.size > b.y
  );
}
const keys = {};
document.addEventListener("keydown", e => {
  // If user is typing into an input, don't trigger item activation or movement bindings
  if (document.activeElement && document.activeElement.tagName === "INPUT") {
    // allow setting bindings with keyboard but do nothing else
    return;
  }

  const key = e.key.toLowerCase();

  // Item activation by bound keys
  if (key === bindSlow.toLowerCase()) { activateSlowItem(); return; }
  if (key === bindPierce.toLowerCase()) { activatePierceItem(); return; }
  if (key === bindSkip.toLowerCase()) { activateSkipItem(); return; }

  keys[e.key.toLowerCase()] = true;
  if (e.code === "Space") shoot();
  if (e.shiftKey) buildWall();

  if (["w","a","s","d"].includes(e.key.toLowerCase())) {
    switch(e.key.toLowerCase()) {
      case "w": player.lastDir = "up"; break;
      case "s": player.lastDir = "down"; break;
      case "a": player.lastDir = "left"; break;
      case "d": player.lastDir = "right"; break;
    }
  }
  if (e.key === "Escape") togglePause();
});
document.addEventListener("keyup", e => delete keys[e.key.toLowerCase()]);

// --- MOUSE HANDLERS (FIX) ---
// Linksklick schießt; Rechtsklick baut Wand (und verhindert Kontextmenü).
// Diese Handler sind die minimale Änderung um Linksklick/ Rechtsklick zu aktivieren.
canvas.addEventListener("mousedown", (e) => {
  // Wenn ein Input gerade fokussiert ist, ignoriere Mausklicks (benutzer tippt)
  if (document.activeElement && document.activeElement.tagName === "INPUT") return;
  // left click -> shoot
  if (e.button === 0) {
    shoot();
  }
  // right click -> build wall
  if (e.button === 2) {
    buildWall();
  }
});
// Verhindere das Kontextmenü auf dem Canvas (so dass Rechtsklick für das Spiel genutzt wird)
canvas.addEventListener("contextmenu", (e) => { e.preventDefault(); });
function handleMovement() {
  let dx = 0, dy = 0;
  if (keys["w"]) dy -= 1;
  if (keys["s"]) dy += 1;
  if (keys["a"]) dx -= 1;
  if (keys["d"]) dx += 1;

  const len = Math.hypot(dx, dy);
  if (len > 0) { dx = (dx / len) * player.speed; dy = (dy / len) * player.speed; }

  player.x = (player.x + dx + canvas.width) % canvas.width;
  player.y = (player.y + dy + canvas.height) % canvas.height;
}
function shoot() {
  const size = 6;
  const speed = 6.75;
  let dx = 0, dy = 0;
  if (keys["w"]) dy -= 1;
  if (keys["s"]) dy += 1;
  if (keys["a"]) dx -= 1;
  if (keys["d"]) dx += 1;

  const len = Math.hypot(dx, dy);
  if (len > 0) { dx = (dx/len)*speed; dy = (dy/len)*speed; }
  else {
    switch(player.lastDir) {
      case "up": dy = -speed; break;
      case "down": dy = speed; break;
      case "left": dx = -speed; break;
      case "right": dx = speed; break;
    }
  }

  bullets.push({
    x: player.x + player.size/2 - size/2,
    y: player.y + player.size/2 - size/2,
    dx, dy, size,
    piercing: playerPiercing
  });

  // consume piercing on fire (it was set when player activated item)
  if (playerPiercing) playerPiercing = false;
}

function buildWall() {
  if (walls.length >= maxWalls) return;
  const offset = 25;
  let wx = player.x, wy = player.y;
  switch(player.lastDir) {
    case "up": wy -= offset; break;
    case "down": wy += offset; break;
    case "left": wx -= offset; break;
    case "right": wx += offset; break;
  }
  walls.push({ x: wx, y: wy, size: 20 });
  totalWallsBuilt++;
}

function moveEnemies() {
  enemies.forEach(e => {
    const dx = player.x - e.x;
    const dy = player.y - e.y;
    const dist = Math.hypot(dx, dy) || 1;
    const effectiveSpeed = (e.baseSpeed || e.speed) * enemySlowMultiplier;
    const moveX = (dx / dist) * effectiveSpeed;
    const moveY = (dy / dist) * effectiveSpeed;

    if (!checkWallCollision(e.x + moveX, e.y, e.size, e.size)) e.x += moveX;
    if (!checkWallCollision(e.x, e.y + moveY, e.size, e.size)) e.y += moveY;

    if (isColliding(e, player) && player.alive) {
      player.alive = false;
      cancelAnimationFrame(animationId);
      gameOver();
    }
  });
}
function moveBullets() {
  bullets.forEach((b, i) => {
    b.x += b.dx; b.y += b.dy;

    if (b.x < -50 || b.x > canvas.width+50 || b.y < -50 || b.y > canvas.height+50) { bullets.splice(i,1); return; }

    if (!b.piercing && checkWallCollision(b.x, b.y, b.size, b.size)) { bullets.splice(i,1); return; }

    for (let j = enemies.length - 1; j >= 0; j--) {
      const e = enemies[j];
      if (isColliding(b, e)) {
        if (!b.piercing) bullets.splice(i,1);
        enemies.splice(j,1);
        score++; coins++;
        saveGame();
        break;
      }
    }
  });
}
function spawnWave(isRevive=false) {
  const count = wave + 2;
  if (!isRevive) walls = [];
  for (let i = 0; i < count; i++) {
    const side = Math.floor(Math.random() * 4);
    let x, y;
    switch (side) {
      case 0: x = 0; y = Math.random() * canvas.height; break;
      case 1: x = canvas.width; y = Math.random() * canvas.height; break;
      case 2: x = Math.random() * canvas.width; y = 0; break;
      case 3: x = Math.random() * canvas.width; y = canvas.height; break;
    }
    enemies.push({ x, y, size: 20, speed: enemySpeed, baseSpeed: enemySpeed });
  }
  if (!isRevive) { wave++; enemySpeed += 0.15; saveGame(); }
}

function applySlowItemEffect() {
  if (slowTimeoutId) clearTimeout(slowTimeoutId);
  enemySlowMultiplier = 0.5;
  slowTimeoutId = setTimeout(() => { enemySlowMultiplier = 1; slowTimeoutId = null; }, 5000);
}
function activateSlowItem() {
  if (inventory.slow <= 0) { /* no item */ return; }
  inventory.slow--;
  applySlowItemEffect();
  saveGame();
  renderShop();
}

function activatePierceItem() {
  if (inventory.pierce <= 0) return;
  inventory.pierce--;
  playerPiercing = true;
  saveGame();
  renderShop();
}

function activateSkipItem() {
  if (inventory.skip <= 0) return;
  inventory.skip--;
  // skip current wave: increment wave and spawn new
  wave++;
  spawnWave();
  saveGame();
  renderShop();
}

function saveGame() {
  localStorage.setItem("score", score);
  localStorage.setItem("coins", coins);
  localStorage.setItem("wave", wave);
  localStorage.setItem("enemySpeed", enemySpeed);
  localStorage.setItem("highScore", highScore);
  localStorage.setItem("highWave", highWave);
  // save bindings and inventory
  localStorage.setItem("bindSlow", bindSlow);
  localStorage.setItem("bindPierce", bindPierce);
  localStorage.setItem("bindSkip", bindSkip);
  localStorage.setItem("inventory", JSON.stringify(inventory));
}
// deterministic RNG mulberry32
function mulberry32(a) {
  return function() {
    a |= 0; a = a + 0x6D2B79F5 | 0;
    var t = Math.imul(a ^ a >>> 15, 1 | a);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
}
const ITEMS = {
  slow: { id: "slow", name: "Slow (5s -50%)", price: 20, desc: "Gegner 5s langsamer" },
  pierce: { id: "pierce", name: "Piercing Shot (nächster Schuss)", price: 10, desc: "Nächster Schuss durchdringt Gegner & Wände" },
  skip: { id: "skip", name: "Wave Skip", price: 60, desc: "Überspringe eine Welle" }
};
let shopStock = { slow: 1, pierce: 0, skip: 0 };

function calculateStockForTick(tick) {
  const rand = mulberry32(tick);
  const stock = { slow: 1, pierce: 0, skip: 0 };

  if (rand() < 0.5) stock.slow = 2;
  if (rand() < 0.33) stock.slow = Math.min(3, stock.slow + 1);

  const rPierce = rand();
  if (rPierce < 0.5) stock.pierce = 1;
  if (rPierce < 0.2) stock.pierce = 2;

  if (rand() < 0.1) stock.skip = 1;

  return stock;
}

function updateShopStockFromNow() {
  const tick = Math.floor(Date.now() / (5 * 60 * 1000));
  shopStock = calculateStockForTick(tick);
  renderShop();
  updateRestockTimer();
}

// render shop showing stock and buy buttons, buying increments inventory (not auto-apply)
function renderShop() {
  shopListEl.innerHTML = "";
  for (const key of ["slow","pierce","skip"]) {
    const it = ITEMS[key];
    const count = shopStock[key] || 0;
    const row = document.createElement("div");
    row.className = "item-row";
    row.innerHTML = `<div>
        <strong>${it.name}</strong>
        <div class="small">${it.desc} — Preis: ${it.price} Münzen</div>
        <div class="small">Du hast: ${inventory[key] || 0}</div>
      </div>
      <div>
        <div class="small">Stock: ${count}</div>
        <button data-item="${key}" ${count===0 ? "disabled" : ""}>Kaufen</button>
      </div>`;
    shopListEl.appendChild(row);
    row.querySelector("button").addEventListener("click", () => buyItem(key));
  }
  shopCoinsEl.textContent = coins;
  startCoinsEl.textContent = coins;
  // also update inventory in localStorage display
}

function buyItem(key) {
  const it = ITEMS[key];
  if (!shopStock[key] || shopStock[key] <= 0) { alert("Nicht vorrätig"); return; }
  if (coins < it.price) { alert("Nicht genug Münzen"); return; }
  coins -= it.price;
  shopStock[key]--;
  inventory[key] = (inventory[key] || 0) + 1;
  saveGame();
  renderShop();
}
function updateRestockTimer() {
  const msPerTick = 5 * 60 * 1000;
  const now = Date.now();
  const tick = Math.floor(now / msPerTick);
  const nextTickStart = (tick + 1) * msPerTick;
  const diff = Math.max(0, nextTickStart - now);
  const minutes = Math.floor(diff / 60000);
  const seconds = Math.floor((diff % 60000) / 1000);
  restockTimerEl.textContent = `${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}`;
}

let lastTick = Math.floor(Date.now() / (5 * 60 * 1000));
setInterval(() => {
  const tick = Math.floor(Date.now() / (5 * 60 * 1000));
  if (tick !== lastTick) {
    lastTick = tick;
    updateShopStockFromNow();
  } else {
    updateRestockTimer();
  }
}, 1000);

// wiring
openShopBtn.addEventListener("click", () => { shopScreen.style.display = "flex"; renderShop(); });
closeShopBtn.addEventListener("click", () => { shopScreen.style.display = "none"; });
shopCloseX.addEventListener("click", () => {
  // close shop and return to main menu (start screen)
  shopScreen.style.display = "none";
  startScreen.style.display = "flex";
});
playBtn.addEventListener("click", () => {
  startScreen.style.display = "none";
  spawnWave();
  gameLoop();
});

// Pause / Resume wiring
document.getElementById("resumeBtn").addEventListener("click", togglePause);
reviveBtn.addEventListener("click", () => {
  if (coins >= 100) {
    coins -= 100;
    player.alive = true;
    bullets = [];
    enemies = [];
    spawnWave(true);
    gameOverScreen.style.display = "none";
    saveGame();
    gameLoop();
  } else alert("Nicht genug Münzen!");
});
restartBtn.addEventListener("click", () => {
  enemies = []; bullets = []; walls = [];
  score = 0; wave = 1; enemySpeed = 1.5;
  totalWallsBuilt = 0;
  player.alive = true; player.x = 400; player.y = 300;
  gameOverScreen.style.display = "none";
  saveGame();
  spawnWave();
  gameLoop();
});

// binding inputs: when user changes an input, save binding (both start and pause mirrored)
function setBindingsFromInputs() {
  const a = (bindingSlow.value || "").slice(0,1) || bindSlow;
  const b = (bindingPierce.value || "").slice(0,1) || bindPierce;
  const c = (bindingSkip.value || "").slice(0,1) || bindSkip;
  bindSlow = a.toLowerCase(); bindPierce = b.toLowerCase(); bindSkip = c.toLowerCase();
  // mirror to pause inputs
  pauseBindingSlow.value = bindingSlow.value.toUpperCase();
  pauseBindingPierce.value = bindingPierce.value.toUpperCase();
  pauseBindingSkip.value = bindingSkip.value.toUpperCase();
  localStorage.setItem("bindSlow", bindSlow);
  localStorage.setItem("bindPierce", bindPierce);
  localStorage.setItem("bindSkip", bindSkip);
}

bindingSlow.addEventListener("change", setBindingsFromInputs);
bindingPierce.addEventListener("change", setBindingsFromInputs);
bindingSkip.addEventListener("change", setBindingsFromInputs);
pauseBindingSlow.addEventListener("change", (e) => { bindingSlow.value = pauseBindingSlow.value; setBindingsFromInputs(); });
pauseBindingPierce.addEventListener("change", (e) => { bindingPierce.value = pauseBindingPierce.value; setBindingsFromInputs(); });
pauseBindingSkip.addEventListener("change", (e) => { bindingSkip.value = pauseBindingSkip.value; setBindingsFromInputs(); });

// load saved inventory if any
const savedInv = localStorage.getItem("inventory");
if (savedInv) {
  try { inventory = JSON.parse(savedInv); } catch(e){ inventory = { slow:0,pierce:0,skip:0 }; }
}

// initial rendering of the shop stock (based on current tick)
updateShopStockFromNow();

// Start screen visible on load; update coins/bindings
window.addEventListener("load", () => {
  startScreen.style.display = "flex";
  startCoinsEl.textContent = coins;
  shopCoinsEl.textContent = coins;
  bindingSlow.value = (localStorage.getItem("bindSlow") || bindSlow).toUpperCase();
  bindingPierce.value = (localStorage.getItem("bindPierce") || bindPierce).toUpperCase();
  bindingSkip.value = (localStorage.getItem("bindSkip") || bindSkip).toUpperCase();
  pauseBindingSlow.value = bindingSlow.value;
  pauseBindingPierce.value = bindingPierce.value;
  pauseBindingSkip.value = bindingSkip.value;
});

// Game loop + helpers
let animationId;
function togglePause() {
  if (!player.alive) return;
  paused = !paused;
  pauseMenu.style.display = paused ? "flex" : "none";
  if (!paused && player.alive) requestAnimationFrame(gameLoop);
}

function gameOver() {
  gameOverScreen.style.display = "flex";
  finalScore.textContent = `Punkte: ${score} | Münzen: ${coins}`;
  if (score > highScore) highScore = score;
  if (wave - 1 > highWave) highWave = wave - 1;
  saveGame();
}

function gameLoop() {
  if (paused || !player.alive) return;

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  handleMovement();
  moveEnemies();
  moveBullets();
  drawPlayer();
  drawBullets();
  drawEnemies();
  drawWalls();
  drawUI();

  if (enemies.length === 0 && spawnCooldown <= 0) {
    spawnWave();
    spawnCooldown = 100;
  }
  if (spawnCooldown > 0) spawnCooldown--;

  animationId = requestAnimationFrame(gameLoop);
}
</script>
</body>
</html>
