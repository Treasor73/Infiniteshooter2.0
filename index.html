<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Survival Spiel</title>
<style>
canvas {
  background: #111;
  display: block;
  margin: auto;
}
body {
  margin: 0;
  overflow: hidden;
  user-select: none;
  font-family: Arial, sans-serif;
}
#pauseMenu, #gameOverScreen {
  position: absolute;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  background: rgba(0,0,0,0.8);
  color: white;
}
button {
  margin: 10px;
  padding: 10px 20px;
  font-size: 16px;
  border: none;
  border-radius: 8px;
  cursor: pointer;
}
</style>
</head>
<body>
<canvas id="gameCanvas" width="800" height="600"></canvas>
<div id="pauseMenu">
  <h1>Pausiert</h1>
  <p>Steuerung:</p>
  <ul style="text-align:left;">
    <li><b>WASD</b> – Bewegen</li>
    <li><b>Linksklick</b> – Schießen</li>
    <li><b>Rechtsklick</b> – Wand platzieren</li>
    <li><b>ESC</b> – Pause</li>
  </ul>
  <button id="resumeBtn">Fortsetzen</button>
</div>

<div id="gameOverScreen">
  <h1>GAME OVER</h1>
  <p id="finalScore"></p>
  <button id="reviveBtn">Für 100 Münzen wiederbeleben</button>
  <button id="restartBtn">Neustart</button>
</div>
<script>
// === Storage laden, falls vorhanden ===
const savedWave = localStorage.getItem("wave");
const savedEnemySpeed = localStorage.getItem("enemySpeed");
const savedScore = localStorage.getItem("score");
const savedCoins = localStorage.getItem("coins");
const savedHighScore = localStorage.getItem("highScore");
const savedHighWave = localStorage.getItem("highWave");

const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const pauseMenu = document.getElementById("pauseMenu");
const gameOverScreen = document.getElementById("gameOverScreen");
const finalScore = document.getElementById("finalScore");
const reviveBtn = document.getElementById("reviveBtn");
const restartBtn = document.getElementById("restartBtn");

const player = {
  x: 400,
  y: 300,
  size: 20,
  speed: 6, // doppelt Original
  lastDir: "right",
  alive: true
};

let bullets = [];
let enemies = [];
let walls = [];
let totalWallsBuilt = 0;

let maxWalls = 10;
let wave = savedWave !== null ? parseInt(savedWave) : 1;
let enemySpeed = savedEnemySpeed !== null ? parseFloat(savedEnemySpeed) : 2;
let spawnCooldown = 0;
let paused = false;
let score = savedScore !== null ? parseInt(savedScore) : 0;
let coins = savedCoins !== null ? parseInt(savedCoins) : 0;
let highScore = savedHighScore !== null ? parseInt(savedHighScore) : 0;
let highWave = savedHighWave !== null ? parseInt(savedHighWave) : 0;
function drawPlayer() {
  ctx.fillStyle = "cyan";
  ctx.fillRect(player.x, player.y, player.size, player.size);
}

function drawBullets() {
  bullets.forEach(b => {
    // schnellere Bullets visualisieren
    ctx.fillStyle = (Math.hypot(b.dx, b.dy) > 6) ? "yellow" : "white";
    ctx.fillRect(b.x, b.y, b.size, b.size);
  });
}

function drawEnemies() {
  ctx.fillStyle = "red";
  enemies.forEach(e => ctx.fillRect(e.x, e.y, e.size, e.size));
}

function drawWalls() {
  ctx.fillStyle = "gray";
  walls.forEach(w => ctx.fillRect(w.x, w.y, w.size, w.size));
}

function drawUI() {
  ctx.fillStyle = "white";
  ctx.font = "20px Arial";
  ctx.fillText(`Welle: ${wave-1}`, 10, 25);
  ctx.fillText(`Wände: ${totalWallsBuilt}/${maxWalls}`, 10, 50);
  ctx.fillText(`Punkte: ${score}`, 10, 75);
  ctx.fillText(`Münzen: ${coins}`, 10, 100);
  ctx.fillText(`Highscore: ${highScore}`, 10, 125);
  ctx.fillText(`Rekordwelle: ${highWave}`, 10, 150);
}
function checkWallCollision(x, y, w, h) {
  return walls.some(wall => (
    x < wall.x + wall.size &&
    x + w > wall.x &&
    y < wall.y + wall.size &&
    y + h > wall.y
  ));
}

function isColliding(a, b) {
  return (
    a.x < b.x + b.size &&
    a.x + a.size > b.x &&
    a.y < b.y + b.size &&
    a.y + a.size > b.y
  );
}
const keys = {};
document.addEventListener("keydown", e => {
  keys[e.key.toLowerCase()] = true;
  if (["w","a","s","d"].includes(e.key.toLowerCase())) {
    switch(e.key.toLowerCase()) {
      case "w": player.lastDir = "up"; break;
      case "s": player.lastDir = "down"; break;
      case "a": player.lastDir = "left"; break;
      case "d": player.lastDir = "right"; break;
    }
  }
  if (e.key === "Escape") togglePause();
});
document.addEventListener("keyup", e => delete keys[e.key.toLowerCase()]);

function handleMovement() {
  let dx = 0, dy = 0;
  if (keys["w"]) dy -= 1;
  if (keys["s"]) dy += 1;
  if (keys["a"]) dx -= 1;
  if (keys["d"]) dx += 1;

  const len = Math.hypot(dx, dy);
  if (len > 0) { dx = (dx / len) * player.speed; dy = (dy / len) * player.speed; }

  player.x = (player.x + dx + canvas.width) % canvas.width;
  player.y = (player.y + dy + canvas.height) % canvas.height;
}
function shoot() {
  const size = 6;
  const speed = 9;
  let dx = 0, dy = 0;
  if (keys["w"]) dy -= 1;
  if (keys["s"]) dy += 1;
  if (keys["a"]) dx -= 1;
  if (keys["d"]) dx += 1;

  const len = Math.hypot(dx, dy);
  if (len > 0) { dx = (dx/len)*speed; dy = (dy/len)*speed; }
  else {
    switch(player.lastDir) {
      case "up": dy = -speed; break;
      case "down": dy = speed; break;
      case "left": dx = -speed; break;
      case "right": dx = speed; break;
    }
  }

  bullets.push({
    x: player.x + player.size/2 - size/2,
    y: player.y + player.size/2 - size/2,
    dx, dy, size
  });
}

function buildWall() {
  if (walls.length >= maxWalls) return;
  const offset = 25;
  let wx = player.x, wy = player.y;
  switch(player.lastDir) {
    case "up": wy -= offset; break;
    case "down": wy += offset; break;
    case "left": wx -= offset; break;
    case "right": wx += offset; break;
  }
  walls.push({ x: wx, y: wy, size: 20 });
  totalWallsBuilt++;
}
function moveEnemies() {
  enemies.forEach(e => {
    const dx = player.x - e.x, dy = player.y - e.y;
    const dist = Math.hypot(dx, dy) || 1;
    const moveX = (dx / dist) * e.speed, moveY = (dy / dist) * e.speed;
    if (!checkWallCollision(e.x + moveX, e.y, e.size, e.size)) e.x += moveX;
    if (!checkWallCollision(e.x, e.y + moveY, e.size, e.size)) e.y += moveY;
    if (isColliding(e, player)) player.alive = false;
  });
}

function moveBullets() {
  bullets.forEach((b, i) => {
    b.x += b.dx; b.y += b.dy;

    if (b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height) { bullets.splice(i,1); return; }

    if (checkWallCollision(b.x, b.y, b.size, b.size)) { bullets.splice(i,1); return; }

    enemies.forEach((e, j) => {
      if (isColliding(b, e)) {
        bullets.splice(i,1);
        enemies.splice(j,1);
        score++; coins++;
        saveGame();
      }
    });
  });
}
function spawnWave(isRevive=false) {
  const count = wave + 2;
  if (!isRevive) {
    // Wände nach jeder echten neuen Wave resetten (Counter bleibt erhalten)
    walls = [];
  }
  for (let i = 0; i < count; i++) {
    const side = Math.floor(Math.random() * 4);
    let x, y;
    switch (side) {
      case 0: x = 0; y = Math.random() * canvas.height; break;
      case 1: x = canvas.width; y = Math.random() * canvas.height; break;
      case 2: x = Math.random() * canvas.width; y = 0; break;
      case 3: x = Math.random() * canvas.width; y = canvas.height; break;
    }
    enemies.push({ x, y, size: 20, speed: enemySpeed });
  }
  if (!isRevive) {
    wave++;
    enemySpeed += 0.15;
    saveGame();
  }
}

function togglePause() {
  paused = !paused;
  pauseMenu.style.display = paused ? "flex" : "none";
  if (!paused && player.alive) requestAnimationFrame(gameLoop);
}

function gameOver() {
  gameOverScreen.style.display = "flex";
  finalScore.textContent = `Punkte: ${score} | Münzen: ${coins}`;
  if (score > highScore) highScore = score;
  if (wave - 1 > highWave) highWave = wave - 1;
  saveGame();
}

reviveBtn.addEventListener("click", () => {
  if (coins >= 100) {
    coins -= 100;
    player.alive = true;
    bullets = [];
    enemies = [];
    spawnWave(true); // revive = true -> wave bleibt gleich
    gameOverScreen.style.display = "none";
    saveGame();
    gameLoop();
  } else alert("Nicht genug Münzen!");
});

restartBtn.addEventListener("click", () => {
  enemies = []; bullets = []; walls = [];
  score = 0; wave = 1; enemySpeed = 2;
  player.alive = true; player.x = 400; player.y = 300;
  gameOverScreen.style.display = "none";
  saveGame();
  spawnWave();
  gameLoop();
});

document.getElementById("resumeBtn").addEventListener("click", togglePause);
canvas.addEventListener("mousedown", e => {
  e.preventDefault();
  if (e.button === 0) shoot();
  else if (e.button === 2) buildWall();
});
canvas.addEventListener("contextmenu", e => e.preventDefault());

function saveGame() {
  localStorage.setItem("score", score);
  localStorage.setItem("coins", coins);
  localStorage.setItem("wave", wave);
  localStorage.setItem("enemySpeed", enemySpeed);
  localStorage.setItem("highScore", highScore);
  localStorage.setItem("highWave", highWave);
}

function gameLoop() {
  // BLACKSCREEN-FIX: robuster Start: falls pausiert oder tot -> nicht weiter zeichnen
  if (paused || !player.alive) return;

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  handleMovement();
  moveEnemies();
  moveBullets();
  drawPlayer();
  drawBullets();
  drawEnemies();
  drawWalls();
  drawUI();

  if (enemies.length === 0 && spawnCooldown <= 0) {
    spawnWave();
    spawnCooldown = 100;
  }
  if (spawnCooldown > 0) spawnCooldown--;

  requestAnimationFrame(gameLoop);
}

// === Spielstart ===
spawnWave();
gameLoop();
</script>
</body>
</html>
